package gpt;

public class GreatestCommonDivisor {

    public static void main(String[] args) {

        int a = 12;
        int b = 18;




    }

    /**
     * 두 수 a와 b의 최대 공약수를 구하는 방법은 다양합니다.
     * 그 중 한 가지 방법이 유클리드 호제법입니다.
     * 유클리드 호제법은 큰 수를 작은 수로 나눈 나머지를 구하고, 작은 수를 나머지로 나눈 나머지를 구하는 과정을 반복하여, 나머지가 0이 될 때까지 구한 마지막 수가 최대 공약수가 되는 원리입니다.
     *
     * 여기서, 위 코드는 재귀 함수를 사용하여 이러한 과정을 구현한 것입니다.
     * 함수의 인자로 받은 a와 b를 이용하여, b가 0이 되면 a를 반환하고, 그렇지 않으면 a를 b로 나눈 나머지를 구해 b와 함께 다시 함수를 호출합니다.
     * 이 과정을 b가 0이 될 때까지 반복하여, 마지막에 구한 b가 최대 공약수가 됩니다.
     *
     * 예를 들어, a = 12, b = 18인 경우를 생각해보겠습니다. 이 경우, 함수가 호출되면 다음과 같이 실행됩니다.
     *
     * - gcd(12, 18) → gcd(18, 12) → gcd(12, 6) → gcd(6, 0)
     *
     * 위와 같이 b가 0이 되면, 마지막으로 구한 a인 6이 최대 공약수가 됩니다.
     *
     * 따라서, 재귀 함수를 사용한 유클리드 호제법은 간단하면서도 효율적인 방법으로, 초등학생도 이해할 수 있습니다.
     */

    /**
     * 위 코드는 재귀 함수를 이용하여 두 정수의 최대 공약수를 구하는 방법입니다.
     * 함수의 인자로 두 정수 a와 b를 받습니다.
     * 만약 b가 0이면, a를 반환합니다.
     *
     * 그렇지 않은 경우, b와 a % b를 인자로 하여 함수를 재귀적으로 호출합니다.
     * 이 과정을 반복하여 마지막으로 구한 나머지가 최대 공약수가 됩니다.
     *
     * ※ 각주: 위 코드에서 a와 b는 양의 정수로 가정합니다.
     * 또한, 이 코드는 a와 b 중에서 작은 값을 b에 대입하고 있으므로, a와 b의 크기에 따라 최대 공약수를 구하는 속도가 차이가 날 수 있습니다.
     * 이를 보완하기 위해서는 a와 b의 크기를 비교하여 조정해주는 로직을 추가해야 합니다.

     */
    public static int gcd(int a, int b) {
        if(b == 0) return a;
        else return gcd(b, a % b);
    }

}
